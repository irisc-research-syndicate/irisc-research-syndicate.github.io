---
title: Finding SHA256
author: Jonas Rudloff
layout: post
---

In the previous article we looked at the iRISC instruction set, and our analysis concluded that its a RISC instruction set simmilar to MISP. We found some promissing patterns, however we are missing alot of knowlegde about the instruction set to be able to make any sense of the firmware, in particular we only know a few instructions: `st`, `ld`, `add`.

After looking around in the `IRON_PREP_CODE` section to try to figure out more of the instruction set we found the following chunk of high entropy near the end of the section:
```
00015510  42 8a 2f 98  71 37 44 91  b5 c0 fb cf  e9 b5 db a5  │B·/·│q7D·│····│····│
00015520  39 56 c2 5b  59 f1 11 f1  92 3f 82 a4  ab 1c 5e d5  │9V·[│Y···│·?··│··^·│
00015530  d8 07 aa 98  12 83 5b 01  24 31 85 be  55 0c 7d c3  │····│··[·│$1··│U·}·│
00015540  72 be 5d 74  80 de b1 fe  9b dc 06 a7  c1 9b f1 74  │r·]t│····│····│···t│
00015550  e4 9b 69 c1  ef be 47 86  0f c1 9d c6  24 0c a1 cc  │··i·│··G·│····│$···│
00015560  2d e9 2c 6f  4a 74 84 aa  5c b0 a9 dc  76 f9 88 da  │-·,o│Jt··│\···│v···│
00015570  98 3e 51 52  a8 31 c6 6d  b0 03 27 c8  bf 59 7f c7  │·>QR│·1·m│··'·│·Y··│
00015580  c6 e0 0b f3  d5 a7 91 47  06 ca 63 51  14 29 29 67  │····│···G│··cQ│·))g│
00015590  27 b7 0a 85  2e 1b 21 38  4d 2c 6d fc  53 38 0d 13  │'···│.·!8│M,m·│S8··│
000155a0  65 0a 73 54  76 6a 0a bb  81 c2 c9 2e  92 72 2c 85  │e·sT│vj··│···.│·r,·│
000155b0  a2 bf e8 a1  a8 1a 66 4b  c2 4b 8b 70  c7 6c 51 a3  │····│··fK│·K·p│·lQ·│
000155c0  d1 92 e8 19  d6 99 06 24  f4 0e 35 85  10 6a a0 70  │····│···$│··5·│·j·p│
000155d0  19 a4 c1 16  1e 37 6c 08  27 48 77 4c  34 b0 bc b5  │····│·7l·│'HwL│4···│
000155e0  39 1c 0c b3  4e d8 aa 4a  5b 9c ca 4f  68 2e 6f f3  │9···│N··J│[··O│h.o·│
000155f0  74 8f 82 ee  78 a5 63 6f  84 c8 78 14  8c c7 02 08  │t···│x·co│··x·│····│
00015600  90 be ff fa  a4 50 6c eb  be f9 a3 f7  c6 71 78 f2  │····│·Pl·│····│·qx·│
```

Googling the first 4 bytes `42 8a 2f 98` we figured out that this piece of data is the `K` array from SHA256[1]. This means that the firmware most likely has an SHA256 implementation.

Since the SHA256 algorithm is a well specified algorithm using many defferent operations this is great target for figuring out more of the instruction set.

Looking at open-source implementations of SHA256 we find that the `sha256_init` function contains alot of known constants:
```c
void sha256_init(struct sha256_ctx *ctx) {
	ctx->datalen = 0;
	ctx->bitlen = 0;
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}
```

searching through our disassembly we can find these constants in a function broken up into 16 bit chunks:
```
00013220:	480300bc	unk.12 r0, r3, r0, 0x00bc
00013224:	6c201806	st.d r3, r1, 0x0006
00013228:	703f0ec2	st.d! r1, r1, 0xfec2
0001322c:	6c20b13e	st.d r22, r1, 0x013e
00013230:	6c20b93a	st.d r23, r1, 0x013a

00013234:	fcd73008	unk.3f r6, r23, r6, 0x3008
00013238:	fca62808	unk.3f r5, r6, r5, 0x2808
0001323c:	fc852008	unk.3f r4, r5, r4, 0x2008

00013240:	2004ae85	unk.08 r0, r4, r21, 0xae85
00013244:	2484bb67	unk.09 r4, r4, r23, 0xbb67
00013248:	1c84e667	unk.07 r4, r4, r28, 0xe667
0001324c:	18846a09	unk.06 r4, r4, r13, 0x6a09

00013250:	7820211c	unk.1e r1, r0, r4, 0x211c

00013254:	2004f53a	unk.08 r0, r4, r30, 0xf53a
00013258:	2484a54f	unk.09 r4, r4, r20, 0xa54f
0001325c:	1c84f372	unk.07 r4, r4, r30, 0xf372
00013260:	18843c6e	unk.06 r4, r4, r7, 0x3c6e

00013264:	78202124	unk.1e r1, r0, r4, 0x2124

00013268:	2004688c	unk.08 r0, r4, r13, 0x688c
0001326c:	24849b05	unk.09 r4, r4, r19, 0x9b05
00013270:	1c84527f	unk.07 r4, r4, r10, 0x527f
00013274:	1884510e	unk.06 r4, r4, r10, 0x510e

00013278:	7820212c	unk.1e r1, r0, r4, 0x212c

0001327c:	2004cd19	unk.08 r0, r4, r25, 0xcd19
00013280:	24845be0	unk.09 r4, r4, r11, 0x5be0
00013284:	1c84d9ab	unk.07 r4, r4, r27, 0xd9ab
00013288:	18841f83	unk.06 r4, r4, r3, 0x1f83

0001328c:	78202134	unk.1e r1, r0, r4, 0x2134

00013290:	78200114	unk.1e r1, r0, r0, 0x0114

00013294:	6c20010a	st.d r0, r1, 0x010a
00013298:	00360008	add r22, r1, 8
0001329c:	fec4b008	unk.3f r22, r4, r22, 0xb008
000132a0:	94fffeeb	unk.25 r7, r31, r31, 0xfeeb
000132a4:	fec4b008	unk.3f r22, r4, r22, 0xb008
000132a8:	fee5b808	unk.3f r23, r5, r23, 0xb808
000132ac:	94ffff96	unk.25 r7, r31, r31, 0xff96

000132b0:	6437013a	ld.d r23, r1, 0x13a
000132b4:	6436013e	ld.d r22, r1, 0x13e
000132b8:	00210140	add r1, r1, 320
000132bc:	64230006	ld.d r3, r1, 0x006
000132c0:	fd001825	unk.3f r8, r0, r3, 0x1825
```

from this we can learn:
- `opcode=0x06,0x07,0x08,0x09` is used for loading the sha256 initialization contants into `r4`.
- The iRISC has 64 bit registers: 4 * 16 bit = 64 bit.
- `opcode=0x1e` might be a 64 bit store operation.
- `opcode=0x25` might be a jump/call instruction. Both instances `94fffeeb` and `94ffff96` have large signed constants in the instruction.

References:
===========
[1] https://en.wikipedia.org/wiki/SHA-2
